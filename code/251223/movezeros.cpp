#include<vector>
#include<iostream>

void moveZeroes(std::vector<int>& nums){
    int j = 0; // 左指针、慢指针
    for(int i = 0;i < nums.size();i++){
        if(nums[i]){   // 当前值不为0，需要交换
            if(i != j){ // 不相等交换
                nums[j] = nums[i];  // 非零元素给慢指针，靠前
                nums[i] = 0;
            }
            j++;
        }
    }
}

int main(){
    std::vector<int> nums = {0,1,0,3,12};
    moveZeroes(nums);
    for(int num : nums){
        std::cout<<num<<" ";
    }
    return 0;
}

/*
刚开始看到题目的时候想到的是用双指针，一个在前面找非0元素，一个在后面找0元素，找到了之后交换，后续看到题目说需要保持有效值的顺序，此法不行
后续想到的是用两个指针，都从左边开始，一个找在前面找非0元素（快指针），一个找在后面找0元素（慢指针），找到了之后交换。
遇到的问题是：我不知道如何写停止条件，想的是写三个while，一个while遍历全部元素，一个while找非0元素，一个while找0元素，写了几个小时发现运行不了，gpt帮我改了一下，
有些案例还是无法通过，遂止
gpt把我的代码优化了一下，发现和官方解法思路相同，于是我就开始理解官方代码
官方题解的评论区，有人解释的非常清晰：
如果数组都是非0元素，那么左右指针永远相等，如果数组中有0，那么慢指针会停止不移动，快指针会继续移动找到下一个非0元素，再和当前0元素交换，交换后慢指针需要右移动一位
*/